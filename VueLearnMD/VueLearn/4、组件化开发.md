# 1、什么是组件

> **组件化的思想：**

  如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。
  但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面
  的管理和维护就变得非常容易了。

![20200106160728.png](https://github.com/1134642046/20200106160728.png)

* 我们将一个完整的页面分成很多个组件。
* 每个组件都用于实现页面的一个功能块。
* 而每一个组件又可以进行细分。
# 2、组件的创建步骤
* 创建组件构造器
  

```js
// 1.创建组件构造器对象
const cpnC = Vue.extend({
    template: `
    <div>
      <h2>我是标题</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
    </div>`
})
```

* 注册组件
  

```js
// 2.注册组件，全局组件
Vue.component('cpn1', cpnC)
```

* 使用组件
  

```html
<div id="app">
    <cpn1></cpn1>
</div>
```

# 3、全局与局部组件
* 在Vue对象外创建的组件即为全局组件，可以在任何div中使用，例
  

```js
< script >
    // 1.创建组件构造器对象
    const cpnC = Vue.extend({
        template: `
    <div>
      <h2>我是标题</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
    </div>`
    })
// 2.注册组件，全局组件
Vue.component('cpn1', cpnC)

let vm = new Vue({
    el: '#app'
});
```

组件cpn1可以在id为 `app` ， `app2` 两个div中使用

```html
<div id="app">
    <cpn1></cpn1>
</div>

<div id="app2">
    <cpn1></cpn1>
</div>
```

* 在Vue内部创建的对象，只可以在该对象绑定的标签内使用，即在`app2`中无法使用组件cpn1
  

```js
let vm = new Vue({
    el: '#app',
    components: {
        cpn1: cpnC
    }

});
```

# 4、父子组件

### 1、定义：

  父子组件即在组件A中，注册另一个组件B，使之可以在a中使用，关系上有种父子关系，
因为注册在父组件中，所以组件B在其他位置不可使用

```js
// 1.创建组件A
const cpnA = Vue.extend({
    template: `
    <div>
      <h2>我是标题</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
    </div>`
})

//2、父子组件
const cpnB = Vue.extend({
    template: `
    <div>
      <h2>我是标题</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
      <cpn1></cpn1>
    </div>
    `, //注册组件,子组件
    components: {
        cpn1: cpnA
    }
})
//注册全局组件cpn2
Vue.component('cpn2', cpnB)
```

### 2、注意

# 5、组件语法糖
* 局部组件
  

```js
let vm = new Vue({
    el: '#app',
    components: {
        // 直接定义
        cpn1: {
            template: `<div>
          <h2>我是标题</h2>
          <p>我是内容, 哈哈哈哈</p>
          <p>我是内容, 呵呵呵呵</p>
        </div>`
        }
    }

});
```

* 全局组件
  

```js
//全局
Vue.component('cpn1', {
    template: `
    <div>
      <h2>我是标题</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
    </div>`
})
```

# 6、组件模板抽离写法

# 7、组件的数据存放

1、存放位置

&emsp; 组件中的数据独立于vue实例中的数据，通过函数存放数据，这个函数会返回一个包含数据的对象，

```js
Vue.component('cpn1', {
    template: `
    <div>
      <h2>{{title}}</h2>
      <p>我是内容, 哈哈哈哈</p>
      <p>我是内容, 呵呵呵呵</p>
    </div>`,
    //组件中的数据存放
    data() {
        return {
            title: "hello!"
        }
    }
})
```

2、为什么使用函数存放数据？

&emsp; 组件的编写是为了在项目中进行复用、可以独立使用，但是用常规方式存放数据，
  在一个项目中一个组件在多处使用就会使用相同的变量，一个地方改变会影响其他的页面，
  这并一定是我们想要的。所以

* Vue让每个组件对象都使用函数返回一个新的对象，有独立的数据空间
* Vue会报出错误
# 8、组件通信

在开发中，往往一些数据确实需要从上层传递到下层：

* 比如在一个页面中，我们从服务器请求到了很多的数据。其中一部分数据，并非是我们整个
  页面的大组件来展示的，而是需要下面的子组件进行展示。这个时候，并不会让子组件再次发
  送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)，而且有可能子组
  件需要反馈数据到父组件。

Vue官方提到的数据传输方式：

* 通过props向子组件传递数据
* 通过事件向父组件发送消息

## 1、父向子传递数据

当向子组件传递数据时，需要将子组件的 `props` 值与父组件的data值绑定：

```html
<!-- 将父组件数据绑定到子组件进行传递。 -->
<counter :number1="addNumber" :number2="subNumber"></counter>
```

props的值有两种方式：

* 方式一：字符串数组，数组中的字符串就是传递时的名称。
* 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。
  

```js
// 子组件
const counter = {
    template: "#counter",
    data() {
        return {
            count: 0
        }
    },
    props: {
        //父组件传递数据,对象方式
        number1: {
            type: Number,
            default: 0
        },
        number2: {
            type: Number,
            default: 0
        }
    }
}
//----------------------------------------
//父组件
let vm = new Vue({
    el: '#app',
    data: {
        count: 0,
        addNumber: 0,
        subNumber: 0
    }
})
```

## 2、子向父传递数据

使用自定义事件来完成子向父的数据传递，什么时候需要自定义事件呢？
当子组件需要向父组件传递数据时，就要用到自定义事件了。
而且v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。
所以利用这个特性做到子向父传递数据：

&emsp; 1、 在子组件中，通过$emit()来触发事件。

```js
// 子组件
methods: {
    add() {
        this.count += this.number1;
    },
    sub() {
        this.count -= this.number2;
    },
    commit(count) {
        // 自定义事件childrenCommit，供父组件监听
        this.$emit('children-commit', count);
    }
}
```

&emsp; 2、 在父组件中，通过v-on来监听子组件事件。

```js
methods: {
    show(count) {
        this.count = count;
    }
}
```

&emsp; 3、在标签中监听

```html
<!-- 监听触发，调用父组件show方法 -->
<counter @children-commit="show"></counter>
```

# 9、父子组件访问

# 10、插槽

**插槽作用：**

* 组件的插槽也是为了让我们封装的组件更加具有扩展性。
* 让使用者可以决定组件内部的一些内容到底展示什么。

**例子：**

* 移动开发中，几乎每个页面都有导航栏。导航栏我们必然会封装成
  一个插件，比如nav-bar组件。一旦有了这个组件，我们就可以在多个页面
  中复用了。

* 如何去封装这类的组件呢？
  它们也很多区别，但是也有很多共性。如果，我们每一个单独去封装一个
  组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封
  装。但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些
  是返回，有些中间是搜索，有些是文字，等等。

* 如何封装合适呢？抽取共性，保留不同。
  最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。一旦我们
  预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内
  容。是搜索框，还是文字，还是菜单。由调用者自己来决定。
  

![slot_2020-01-06_15-16-13.png](https://github.com/1134642046/slot_2020-01-06_15-16-13.png)

### 1、普通插槽

  在 `template` 标签中添加 `slot` 标签代表该位置是一个插槽， `<slot>`

  中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内
  容。当父组件中的插槽有内容的时候，将会替换默认插槽的内容。

```html
<div id="app">
    <!-- 写在组件标签内的内容 -->
    <cpn></cpn>
    <cpn>
        <p>不好意思普通插槽！</p>
    </cpn>
</div>
<!-- ---------------------------------------------------- -->
<template id="test">
    <div>
        <h1>Hello!</h1>
        <!-- 定义一个插槽，默认显示开始写好在模板中的数据 -->
        <slot>你好普通插槽！</slot>
    </div>
</template>
```

### &emsp; 2、具名插槽

* 当子组件的功能复杂时，子组件的插槽可能并非是一个。比如我们封装
  一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右
  边。那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？这个
  时候，我们就需要给插槽起一个名字
* 如何使用具名插槽？
  
  给slot元素一个name属性 `<slot name='myslot'></slot>`

```html
<div id="app">
    <cpn><span slot="center">标题</span></cpn>
    <cpn><button slot="left">返回</button></cpn>
</div>

<template id="cpn">
    <div>
        <slot name="left"><span>左边</span></slot>
        <slot name="center"><span>中间</span></slot>
        <slot name="right"><span>右边</span></slot>
    </div>
</template>
<!-- out -->
<div>
    <span>左边</span>
    <span>标题</span>
    <span>右边</span>
</div>
<div>
    <button>返回</button>
    <span>中间</span>
    <span>右边</span>
</div>
```

### &emsp; 3、编译作用域

官方给出了一条准则：

> 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。

id为app的div所在的组件为Vue组件，也是cpn组件的父组件，他的数据作用域就在这个div范围内。如下：

```html
<div id="app">
    <!--   isShow为父组件的变量 -->
    <cpn v-show="isShow"></cpn>
    <cpn v-for="item in names"></cpn>
</div>

<template id="cpn">
    <div>
        <h2>我是子组件</h2>
        <p>我是内容, 哈哈哈</p>
        <!--   因为该模板是cpn组件的模板，所以编译作用域在子级cpn，所以isShow使用的是子组件的变量 -->
        <button v-show="isShow">按钮</button>
    </div>
</template>
```

组件与Vue实例

```js
const app = new Vue({
    el: '#app',
    data: {
        message: '你好啊',
        isShow: true
    },
    components: {
        cpn: {
            template: '#cpn',
            data() {
                return {
                    isShow: false
                }
            }
        },
    }
})
```

### &emsp; 4、作用域插槽

```html
<cpn></cpn>

<cpn>
    <!--目的是获取子组件中的pLanguages,defalult表示默认插槽，即没有
	使用具名插槽 -->
    <template v-slot:default="slot">
        <!--<span v-for="item in slot.data"> - {{item}}</span>-->
        <span>{{slot.data.join(' - ')}}</span>
    </template>
</cpn>

<template id="cpn">
    <div>
        <!-- 绑定子子组件的数据pLanguages,绑定在 <slot> 元素上的特性
被称为插槽 prop-->
        <slot :data="pLanguages">
            <ul>
                <li v-for="item in pLanguages">{{item}}</li>
            </ul>
        </slot>
    </div>
</template>
```

```js
const app = new Vue({
    el: '#app',
    data: {
        message: '你好啊'
    },
    components: {
        cpn: {
            template: '#cpn',
            data() {
                return {
                    pLanguages: ['JavaScript', 'C++', 'Java', 'C#', 'Python', 'Go', 'Swift']
                }
            }
        }
    }
})
```

### &emsp; 5、插槽语法糖

[具名插槽的缩写](https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99)
